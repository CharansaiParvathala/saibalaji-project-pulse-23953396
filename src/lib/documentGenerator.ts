
import { saveAs } from 'file-saver';
import { Project, ProgressEntry, PaymentRequest } from '@/types';
// Import docx from 'docx' will be done at runtime

export interface GenerateDocxOptions {
  title: string;
  projects: Project[];
  progressEntries: ProgressEntry[];
  paymentRequests: PaymentRequest[];
  generatedBy: string;
  generatedDate: string;
}

export async function generateDocx(options: GenerateDocxOptions): Promise<Blob> {
  try {
    // Dynamically import docx library
    const docx = await import('docx');
    const { Document, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, WidthType, AlignmentType, TabStopPosition, TabStopType, TableOfContents, PageBreak } = docx;
    
    // Format date
    const formattedDate = new Date(options.generatedDate).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    
    // Create document title and intro
    const documentTitle = new Paragraph({
      text: options.title,
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: {
        after: 400
      }
    });
    
    const generatedInfo = new Paragraph({
      children: [
        new TextRun({
          text: `Generated by: ${options.generatedBy}`,
          bold: true,
          size: 24
        }),
        new TextRun({
          text: `   Date: ${formattedDate}`,
          bold: true,
          size: 24
        })
      ],
      alignment: AlignmentType.CENTER,
      spacing: {
        after: 400
      }
    });
    
    // Create table of contents
    const toc = new TableOfContents("Table of Contents", {
      hyperlink: true,
      headingStyleRange: {
        start: 1,
        end: 3
      }
    });
    
    const tocHeading = new Paragraph({
      text: "TABLE OF CONTENTS",
      heading: HeadingLevel.HEADING_1,
      spacing: {
        before: 400,
        after: 200
      }
    });
    
    // Add page break before main content
    const pageBreak = new Paragraph({
      children: [
        new PageBreak()
      ]
    });
    
    // PROJECTS SECTION
    const projectsHeading = new Paragraph({
      text: "1. PROJECTS",
      heading: HeadingLevel.HEADING_1,
      spacing: {
        before: 400,
        after: 200
      }
    });
    
    const projectsSummary = new Paragraph({
      text: `Total Projects: ${options.projects.length}`,
      spacing: {
        after: 200
      }
    });
    
    // Create projects table
    const projectsTableRows = [
      new TableRow({
        tableHeader: true,
        children: [
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Project Name", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Status", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 20, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Workers", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 25, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Created By", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 25, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Created At", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          })
        ]
      })
    ];
    
    // Add project rows
    options.projects.forEach(project => {
      projectsTableRows.push(
        new TableRow({
          children: [
            new TableCell({ children: [new Paragraph(project.name)] }),
            new TableCell({ children: [new Paragraph({ text: project.status, alignment: AlignmentType.CENTER })] }),
            new TableCell({ children: [new Paragraph({ text: project.num_workers.toString(), alignment: AlignmentType.CENTER })] }),
            new TableCell({ children: [new Paragraph(project.created_by)] }),
            new TableCell({ children: [new Paragraph(new Date(project.created_at).toLocaleDateString())] })
          ]
        })
      );
    });
    
    const projectsTable = new Table({
      rows: projectsTableRows,
      width: { size: 100, type: WidthType.PERCENTAGE },
      borders: {
        top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" }
      }
    });
    
    // PROGRESS ENTRIES SECTION
    const progressHeading = new Paragraph({
      text: "2. PROGRESS ENTRIES",
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 200 }
    });
    
    const progressSummary = new Paragraph({
      text: `Total Progress Entries: ${options.progressEntries.length}`,
      spacing: { after: 200 }
    });
    
    // Create progress entries table
    const progressTableRows = [
      new TableRow({
        tableHeader: true,
        children: [
          new TableCell({
            width: { size: 20, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Project", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Date", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Status", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Distance", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 35, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Notes", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          })
        ]
      })
    ];
    
    // Add progress entry rows
    options.progressEntries.forEach(entry => {
      const projectName = options.projects.find(p => p.id === (entry.project_id || entry.projectId))?.name || 
                         (entry.project_id || entry.projectId || '');
      
      progressTableRows.push(
        new TableRow({
          children: [
            new TableCell({ children: [new Paragraph(projectName)] }),
            new TableCell({ children: [new Paragraph(new Date(entry.date).toLocaleDateString())] }),
            new TableCell({ children: [new Paragraph({ text: entry.status || "N/A", alignment: AlignmentType.CENTER })] }),
            new TableCell({ children: [
              new Paragraph({ 
                text: (entry.distance_completed || entry.distanceCompleted) ? 
                      `${entry.distance_completed || entry.distanceCompleted} km` : "N/A", 
                alignment: AlignmentType.CENTER 
              })
            ]}),
            new TableCell({ children: [new Paragraph(entry.notes || "")] })
          ]
        })
      );
    });
    
    const progressTable = new Table({
      rows: progressTableRows,
      width: { size: 100, type: WidthType.PERCENTAGE },
      borders: {
        top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" }
      }
    });
    
    // PAYMENT REQUESTS SECTION
    const paymentHeading = new Paragraph({
      text: "3. PAYMENT REQUESTS",
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 200 }
    });
    
    const paymentSummary = new Paragraph({
      text: `Total Payment Requests: ${options.paymentRequests.length}`,
      spacing: { after: 200 }
    });
    
    // Calculate total payment amount
    const totalAmount = options.paymentRequests.reduce((sum, req) => sum + (req.amount || 0), 0);
    const totalAmountText = new Paragraph({
      text: `Total Amount: ₹${totalAmount.toFixed(2)}`,
      spacing: { after: 200 }
    });
    
    // Create payment requests table
    const paymentTableRows = [
      new TableRow({
        tableHeader: true,
        children: [
          new TableCell({
            width: { size: 20, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Project", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Amount (₹)", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Status", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 15, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Requested By", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          }),
          new TableCell({
            width: { size: 35, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: "Description", alignment: AlignmentType.CENTER, bold: true })],
            shading: { fill: "F2F2F2" }
          })
        ]
      })
    ];
    
    // Add payment request rows
    options.paymentRequests.forEach(payment => {
      const projectName = options.projects.find(p => p.id === (payment.project_id || payment.projectId))?.name || 
                         (payment.project_id || payment.projectId || '');
      
      const requestedBy = payment.requested_by || payment.requestedBy || '';
      
      paymentTableRows.push(
        new TableRow({
          children: [
            new TableCell({ children: [new Paragraph(projectName)] }),
            new TableCell({ children: [new Paragraph({ text: `₹${payment.amount.toFixed(2)}`, alignment: AlignmentType.RIGHT })] }),
            new TableCell({ children: [new Paragraph({ text: payment.status, alignment: AlignmentType.CENTER })] }),
            new TableCell({ children: [new Paragraph(requestedBy)] }),
            new TableCell({ children: [new Paragraph(payment.description)] })
          ]
        })
      );
    });
    
    const paymentTable = new Table({
      rows: paymentTableRows,
      width: { size: 100, type: WidthType.PERCENTAGE },
      borders: {
        top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
        insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "000000" }
      }
    });
    
    // Create final document
    const doc = new Document({
      sections: [
        {
          properties: {},
          children: [
            documentTitle,
            generatedInfo,
            tocHeading,
            toc,
            pageBreak,
            projectsHeading,
            projectsSummary,
            projectsTable,
            progressHeading,
            progressSummary,
            progressTable,
            paymentHeading,
            paymentSummary,
            totalAmountText,
            paymentTable
          ]
        }
      ]
    });
    
    // Generate and return as blob
    return await docx.Packer.toBlob(doc);
  } catch (error) {
    console.error("Error generating document:", error);
    throw new Error("Failed to generate document");
  }
}

// PDF generation using PDFKit
export async function generatePDF(options: GenerateDocxOptions): Promise<Blob> {
  try {
    // Dynamically import pdfkit
    // Note: This is a simplified version that would need to be expanded in a real implementation
    const PDFDocument = (await import('pdfkit')).default;
    
    // This is a simplified example - in a real app, you'd create proper PDF document
    // using PDFKit's Node-based API, but for this demo we'll create a basic PDF
    const pdfDoc = new PDFDocument();
    const buffers: Buffer[] = [];
    
    pdfDoc.on('data', buffers.push.bind(buffers));
    
    // Add content to the PDF
    pdfDoc.fontSize(25).text('Construction Project Report', {
      align: 'center'
    });
    
    pdfDoc.moveDown();
    pdfDoc.fontSize(14).text(`Generated by: ${options.generatedBy} on ${new Date(options.generatedDate).toLocaleDateString()}`);
    
    pdfDoc.moveDown();
    pdfDoc.fontSize(18).text('Projects Summary');
    pdfDoc.fontSize(12).text(`Total Projects: ${options.projects.length}`);
    
    // Projects list
    options.projects.forEach((project, i) => {
      pdfDoc.moveDown(0.5);
      pdfDoc.fontSize(14).text(`${i + 1}. ${project.name}`);
      pdfDoc.fontSize(10).text(`Status: ${project.status}`);
      pdfDoc.fontSize(10).text(`Workers: ${project.num_workers}`);
      pdfDoc.fontSize(10).text(`Created by: ${project.created_by}`);
    });
    
    pdfDoc.moveDown();
    pdfDoc.fontSize(18).text('Progress Entries Summary');
    pdfDoc.fontSize(12).text(`Total Progress Entries: ${options.progressEntries.length}`);
    
    pdfDoc.moveDown();
    pdfDoc.fontSize(18).text('Payment Requests Summary');
    pdfDoc.fontSize(12).text(`Total Payment Requests: ${options.paymentRequests.length}`);
    
    // Calculate total payment amount
    const totalAmount = options.paymentRequests.reduce((sum, req) => sum + req.amount, 0);
    pdfDoc.fontSize(12).text(`Total Amount: ₹${totalAmount.toFixed(2)}`);
    
    // Finalize PDF file
    pdfDoc.end();
    
    // Combine all buffers and convert to Blob
    const pdfBuffer = Buffer.concat(buffers);
    return new Blob([pdfBuffer], { type: 'application/pdf' });
    
  } catch (error) {
    console.error("Error generating PDF document:", error);
    throw new Error("Failed to generate PDF document");
  }
}

// Function to generate a report in the specified format
export async function generateReport(options: GenerateDocxOptions, format: "pdf" | "docx" = "docx"): Promise<Blob> {
  try {
    if (format === "pdf") {
      return await generatePDF(options);
    } else {
      return await generateDocx(options);
    }
  } catch (error) {
    console.error(`Error generating ${format.toUpperCase()} report:`, error);
    throw new Error(`Failed to generate ${format.toUpperCase()} report`);
  }
}

// Add these functions for backup/index.tsx
export async function generateDataReport(fileName: string, format: "pdf" | "docx" = "docx"): Promise<Blob> {
  try {
    if (format === "pdf") {
      // Generate a simple PDF report
      const PDFDocument = (await import('pdfkit')).default;
      const pdfDoc = new PDFDocument();
      const buffers: Buffer[] = [];
      
      pdfDoc.on('data', buffers.push.bind(buffers));
      
      // Add content
      pdfDoc.fontSize(25).text('Data Report', {
        align: 'center'
      });
      
      pdfDoc.moveDown();
      pdfDoc.fontSize(14).text(`Report: ${fileName}`);
      pdfDoc.fontSize(14).text(`Generated on: ${new Date().toLocaleDateString()}`);
      
      pdfDoc.moveDown();
      pdfDoc.fontSize(12).text("This report contains exported data from the system.");
      
      // Finalize PDF file
      pdfDoc.end();
      
      // Combine all buffers
      const pdfBuffer = Buffer.concat(buffers);
      return new Blob([pdfBuffer], { type: 'application/pdf' });
    } else {
      // Generate a simple DOCX report
      const docx = await import('docx');
      const { Document, Paragraph, TextRun, HeadingLevel } = docx;
      
      const doc = new Document({
        sections: [
          {
            properties: {},
            children: [
              new Paragraph({
                text: `Data Report: ${fileName}`,
                heading: HeadingLevel.TITLE,
              }),
              new Paragraph({
                text: `Generated on: ${new Date().toLocaleDateString()}`,
              }),
              new Paragraph({
                text: "This report contains exported data from the system.",
              }),
            ],
          },
        ],
      });
      
      return await docx.Packer.toBlob(doc);
    }
  } catch (error) {
    console.error("Error generating report:", error);
    throw new Error("Failed to generate report");
  }
}

export function downloadReport(blob: Blob, fileName: string): void {
  saveAs(blob, `${fileName.replace(/\s+/g, '_')}`);
}
