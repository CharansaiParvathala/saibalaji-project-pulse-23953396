
import { Document, Paragraph, TextRun, Table, TableRow, TableCell, HeadingLevel, PageBreak, TableOfContents, AlignmentType, BorderStyle } from 'docx';
import { saveAs } from 'file-saver';
import PDFDocument from 'pdfkit';

// Define interfaces for report data
interface ReportData {
  title: string;
  projects: any[];
  progressEntries: any[];
  paymentRequests: any[];
  generatedBy: string;
  generatedDate: string;
}

// Function to generate a report blob
export async function generateReport(data: ReportData, format: 'pdf' | 'docx'): Promise<Blob> {
  if (format === 'docx') {
    return generateWordReport(data);
  } else {
    return generatePDFReport(data);
  }
}

// Function to download the report
export function downloadReport(blob: Blob, fileName: string): void {
  saveAs(blob, fileName);
}

// Generate a Word document report
async function generateWordReport(data: ReportData): Promise<Blob> {
  const doc = new Document({
    creator: data.generatedBy,
    title: data.title,
    description: "Generated report from Sai Balaji Construction Management System",
    sections: [
      {
        properties: {},
        children: [
          // Cover page
          new Paragraph({
            text: data.title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { before: 200, after: 100 }
          }),
          new Paragraph({
            text: `Generated on: ${new Date(data.generatedDate).toLocaleDateString()}`,
            alignment: AlignmentType.CENTER,
            spacing: { before: 100, after: 50 }
          }),
          new Paragraph({
            text: `Generated by: ${data.generatedBy}`,
            alignment: AlignmentType.CENTER,
            spacing: { before: 50, after: 200 }
          }),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Table of Contents
          new Paragraph({
            text: "Table of Contents",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          new TableOfContents("Summary", {
            hyperlink: true
          }),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Projects Section
          new Paragraph({
            text: "Projects",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          ...generateProjectsContent(data.projects),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Progress Entries Section
          new Paragraph({
            text: "Progress Entries",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          ...generateProgressContent(data.progressEntries),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Payment Requests Section
          new Paragraph({
            text: "Payment Requests",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          ...generatePaymentContent(data.paymentRequests),
          
          // Footer
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          new Paragraph({
            text: "Sai Balaji Construction - Confidential",
            alignment: AlignmentType.CENTER,
            spacing: { before: 200, after: 0 }
          })
        ]
      }
    ]
  });
  
  return await Packer.toBlob(doc);
}

// Helper function to generate projects table content
function generateProjectsContent(projects: any[]): Paragraph[] {
  if (!projects || projects.length === 0) {
    return [new Paragraph({ text: "No projects available" })];
  }
  
  const content: Paragraph[] = [
    new Paragraph({
      text: `Total Projects: ${projects.length}`,
      spacing: { before: 50, after: 50 }
    })
  ];
  
  // Add project details
  projects.forEach((project, index) => {
    content.push(
      new Paragraph({
        text: `${index + 1}. ${project.name}`,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 50, after: 20 }
      }),
      new Paragraph({
        text: `Status: ${project.status || 'Unknown'}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Created by: ${project.createdBy || project.created_by || 'Unknown'}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Created at: ${new Date(project.createdAt || project.created_at).toLocaleDateString()}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Workers: ${project.numWorkers || project.num_workers || 0}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Total Distance: ${project.totalDistance || project.total_distance || 0} meters`,
        spacing: { before: 10, after: 30 }
      })
    );
  });
  
  return content;
}

// Helper function to generate progress entries content
function generateProgressContent(entries: any[]): Paragraph[] {
  if (!entries || entries.length === 0) {
    return [new Paragraph({ text: "No progress entries available" })];
  }
  
  const content: Paragraph[] = [
    new Paragraph({
      text: `Total Progress Entries: ${entries.length}`,
      spacing: { before: 50, after: 50 }
    })
  ];
  
  // Group entries by project
  const entriesByProject: { [key: string]: any[] } = {};
  entries.forEach(entry => {
    const projectId = entry.projectId || entry.project_id;
    if (!entriesByProject[projectId]) {
      entriesByProject[projectId] = [];
    }
    entriesByProject[projectId].push(entry);
  });
  
  // Add entries by project
  Object.entries(entriesByProject).forEach(([projectId, projectEntries]) => {
    content.push(
      new Paragraph({
        text: `Project ID: ${projectId}`,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 50, after: 20 }
      }),
      new Paragraph({
        text: `Number of entries: ${projectEntries.length}`,
        spacing: { before: 10, after: 20 }
      })
    );
    
    // Add individual entries
    projectEntries.forEach((entry, index) => {
      content.push(
        new Paragraph({
          text: `Entry ${index + 1} - ${new Date(entry.date).toLocaleDateString()}`,
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 30, after: 10 }
        }),
        new Paragraph({
          text: `Distance completed: ${entry.distanceCompleted || entry.distance_completed || 0} meters`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Time spent: ${entry.timeSpent || entry.time_spent || 0} hours`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Workers present: ${entry.workersPresent || entry.workers_present || 0}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Notes: ${entry.notes || 'No notes'}`,
          spacing: { before: 10, after: 20 }
        })
      );
    });
  });
  
  return content;
}

// Helper function to generate payment requests content
function generatePaymentContent(payments: any[]): Paragraph[] {
  if (!payments || payments.length === 0) {
    return [new Paragraph({ text: "No payment requests available" })];
  }
  
  const content: Paragraph[] = [
    new Paragraph({
      text: `Total Payment Requests: ${payments.length}`,
      spacing: { before: 50, after: 50 }
    })
  ];
  
  // Group payments by status
  const paymentsByStatus: { [key: string]: any[] } = {};
  payments.forEach(payment => {
    const status = payment.status || 'unknown';
    if (!paymentsByStatus[status]) {
      paymentsByStatus[status] = [];
    }
    paymentsByStatus[status].push(payment);
  });
  
  // Add payments by status
  Object.entries(paymentsByStatus).forEach(([status, statusPayments]) => {
    content.push(
      new Paragraph({
        text: `${status.toUpperCase()} Payments (${statusPayments.length})`,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 50, after: 20 }
      })
    );
    
    // Add individual payments
    statusPayments.forEach((payment, index) => {
      content.push(
        new Paragraph({
          text: `Payment ${index + 1} - â‚¹${payment.amount.toFixed(2)}`,
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 30, after: 10 }
        }),
        new Paragraph({
          text: `Description: ${payment.description || 'No description'}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Requested by: ${payment.requestedBy || payment.requested_by || 'Unknown'}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Requested on: ${new Date(payment.requestedAt || payment.requested_at).toLocaleDateString()}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Project ID: ${payment.projectId || payment.project_id || 'Unknown'}`,
          spacing: { before: 10, after: 20 }
        })
      );
    });
  });
  
  return content;
}

// Generate a PDF report
async function generatePDFReport(data: ReportData): Promise<Blob> {
  return new Promise((resolve) => {
    // Create a PDF document
    const doc = new PDFDocument({ margin: 50 });
    
    // Collect PDF data chunks
    const chunks: Uint8Array[] = [];
    doc.on('data', (chunk) => chunks.push(chunk));
    doc.on('end', () => {
      const pdfBlob = new Blob(chunks, { type: 'application/pdf' });
      resolve(pdfBlob);
    });
    
    // Add cover page
    doc.fontSize(25).text(data.title, { align: 'center' });
    doc.moveDown(2);
    doc.fontSize(14)
      .text(`Generated on: ${new Date(data.generatedDate).toLocaleDateString()}`, { align: 'center' })
      .moveDown(1)
      .text(`Generated by: ${data.generatedBy}`, { align: 'center' });
    doc.moveDown(4);
    
    // Add projects section
    doc.addPage();
    doc.fontSize(20).text('Projects', { underline: true });
    doc.moveDown(1);
    
    if (data.projects && data.projects.length > 0) {
      doc.fontSize(12).text(`Total Projects: ${data.projects.length}`);
      doc.moveDown(1);
      
      data.projects.forEach((project, index) => {
        doc.fontSize(16).text(`${index + 1}. ${project.name}`);
        doc.fontSize(12)
          .moveDown(0.5)
          .text(`Status: ${project.status || 'Unknown'}`)
          .moveDown(0.5)
          .text(`Created by: ${project.createdBy || project.created_by || 'Unknown'}`)
          .moveDown(0.5)
          .text(`Created at: ${new Date(project.createdAt || project.created_at).toLocaleDateString()}`)
          .moveDown(0.5)
          .text(`Workers: ${project.numWorkers || project.num_workers || 0}`)
          .moveDown(0.5)
          .text(`Total Distance: ${project.totalDistance || project.total_distance || 0} meters`);
        doc.moveDown(1);
      });
    } else {
      doc.fontSize(12).text('No projects available');
    }
    
    // Add progress entries section
    doc.addPage();
    doc.fontSize(20).text('Progress Entries', { underline: true });
    doc.moveDown(1);
    
    if (data.progressEntries && data.progressEntries.length > 0) {
      doc.fontSize(12).text(`Total Progress Entries: ${data.progressEntries.length}`);
      doc.moveDown(1);
      
      // Group entries by project
      const entriesByProject: { [key: string]: any[] } = {};
      data.progressEntries.forEach(entry => {
        const projectId = entry.projectId || entry.project_id;
        if (!entriesByProject[projectId]) {
          entriesByProject[projectId] = [];
        }
        entriesByProject[projectId].push(entry);
      });
      
      // Add entries by project
      Object.entries(entriesByProject).forEach(([projectId, projectEntries]) => {
        doc.fontSize(16).text(`Project ID: ${projectId}`);
        doc.fontSize(12).text(`Number of entries: ${projectEntries.length}`);
        doc.moveDown(1);
        
        projectEntries.forEach((entry, index) => {
          if (index > 0 && index % 3 === 0) {
            doc.addPage(); // Add page break every 3 entries
          }
          
          doc.fontSize(14).text(`Entry ${index + 1} - ${new Date(entry.date).toLocaleDateString()}`);
          doc.fontSize(12)
            .moveDown(0.5)
            .text(`Distance completed: ${entry.distanceCompleted || entry.distance_completed || 0} meters`)
            .moveDown(0.5)
            .text(`Time spent: ${entry.timeSpent || entry.time_spent || 0} hours`)
            .moveDown(0.5)
            .text(`Workers present: ${entry.workersPresent || entry.workers_present || 0}`)
            .moveDown(0.5)
            .text(`Notes: ${entry.notes || 'No notes'}`);
          doc.moveDown(1);
        });
      });
    } else {
      doc.fontSize(12).text('No progress entries available');
    }
    
    // Add payment requests section
    doc.addPage();
    doc.fontSize(20).text('Payment Requests', { underline: true });
    doc.moveDown(1);
    
    if (data.paymentRequests && data.paymentRequests.length > 0) {
      doc.fontSize(12).text(`Total Payment Requests: ${data.paymentRequests.length}`);
      doc.moveDown(1);
      
      // Group payments by status
      const paymentsByStatus: { [key: string]: any[] } = {};
      data.paymentRequests.forEach(payment => {
        const status = payment.status || 'unknown';
        if (!paymentsByStatus[status]) {
          paymentsByStatus[status] = [];
        }
        paymentsByStatus[status].push(payment);
      });
      
      // Add payments by status
      Object.entries(paymentsByStatus).forEach(([status, statusPayments]) => {
        doc.fontSize(16).text(`${status.toUpperCase()} Payments (${statusPayments.length})`);
        doc.moveDown(1);
        
        statusPayments.forEach((payment, index) => {
          if (index > 0 && index % 4 === 0) {
            doc.addPage(); // Add page break every 4 payments
          }
          
          doc.fontSize(14).text(`Payment ${index + 1} - â‚¹${payment.amount.toFixed(2)}`);
          doc.fontSize(12)
            .moveDown(0.5)
            .text(`Description: ${payment.description || 'No description'}`)
            .moveDown(0.5)
            .text(`Requested by: ${payment.requestedBy || payment.requested_by || 'Unknown'}`)
            .moveDown(0.5)
            .text(`Requested on: ${new Date(payment.requestedAt || payment.requested_at).toLocaleDateString()}`)
            .moveDown(0.5)
            .text(`Project ID: ${payment.projectId || payment.project_id || 'Unknown'}`);
          doc.moveDown(1);
        });
      });
    } else {
      doc.fontSize(12).text('No payment requests available');
    }
    
    // Add footer
    doc.fontSize(10).text('Sai Balaji Construction - Confidential', { align: 'center' });
    
    // Finalize the PDF
    doc.end();
  });
}

// Import Packer at top level
import { Packer } from 'docx';
