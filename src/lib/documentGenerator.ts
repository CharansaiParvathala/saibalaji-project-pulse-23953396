
import { Document, Paragraph, TextRun, Table, TableRow, TableCell, HeadingLevel, PageBreak, TableOfContents, AlignmentType, BorderStyle } from 'docx';
import { saveAs } from 'file-saver';
import { Packer } from 'docx';

// Define interfaces for report data
interface ReportData {
  title: string;
  projects: any[];
  progressEntries: any[];
  paymentRequests: any[];
  generatedBy: string;
  generatedDate: string;
}

// Function to generate a report blob
export async function generateReport(data: ReportData, format: 'pdf' | 'docx'): Promise<Blob> {
  // Since PDFKit has issues in the browser, we'll always use docx format
  console.log(`Generating report in ${format} format (defaulting to DOCX due to PDFKit browser limitations)`);
  return generateWordReport(data);
}

// Function to download the report
export function downloadReport(blob: Blob, fileName: string): void {
  saveAs(blob, fileName);
}

// Generate a Word document report
export async function generateWordReport(data: ReportData): Promise<Blob> {
  const doc = new Document({
    creator: data.generatedBy,
    title: data.title,
    description: "Generated report from Sai Balaji Construction Management System",
    sections: [
      {
        properties: {},
        children: [
          // Cover page
          new Paragraph({
            text: data.title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { before: 200, after: 100 }
          }),
          new Paragraph({
            text: `Generated on: ${new Date(data.generatedDate).toLocaleDateString()}`,
            alignment: AlignmentType.CENTER,
            spacing: { before: 100, after: 50 }
          }),
          new Paragraph({
            text: `Generated by: ${data.generatedBy}`,
            alignment: AlignmentType.CENTER,
            spacing: { before: 50, after: 200 }
          }),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Table of Contents
          new Paragraph({
            text: "Table of Contents",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          new TableOfContents("Summary", {
            hyperlink: true
          }),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Projects Section
          new Paragraph({
            text: "Projects",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          ...generateProjectsContent(data.projects),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Progress Entries Section
          new Paragraph({
            text: "Progress Entries",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          ...generateProgressContent(data.progressEntries),
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          
          // Payment Requests Section
          new Paragraph({
            text: "Payment Requests",
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 100, after: 50 }
          }),
          ...generatePaymentContent(data.paymentRequests),
          
          // Footer
          new Paragraph({
            text: "",
            pageBreakBefore: true
          }),
          new Paragraph({
            text: "Sai Balaji Construction - Confidential",
            alignment: AlignmentType.CENTER,
            spacing: { before: 200, after: 0 }
          })
        ]
      }
    ]
  });
  
  return await Packer.toBlob(doc);
}

// Helper function to generate projects table content
function generateProjectsContent(projects: any[]): Paragraph[] {
  if (!projects || projects.length === 0) {
    return [new Paragraph({ text: "No projects available" })];
  }
  
  const content: Paragraph[] = [
    new Paragraph({
      text: `Total Projects: ${projects.length}`,
      spacing: { before: 50, after: 50 }
    })
  ];
  
  // Add project details
  projects.forEach((project, index) => {
    content.push(
      new Paragraph({
        text: `${index + 1}. ${project.name}`,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 50, after: 20 }
      }),
      new Paragraph({
        text: `Status: ${project.status || 'Unknown'}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Created by: ${project.createdBy || project.created_by || 'Unknown'}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Created at: ${new Date(project.createdAt || project.created_at).toLocaleDateString()}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Workers: ${project.numWorkers || project.num_workers || 0}`,
        spacing: { before: 10, after: 10 }
      }),
      new Paragraph({
        text: `Total Distance: ${project.totalDistance || project.total_distance || 0} meters`,
        spacing: { before: 10, after: 30 }
      })
    );
  });
  
  return content;
}

// Helper function to generate progress entries content
function generateProgressContent(entries: any[]): Paragraph[] {
  if (!entries || entries.length === 0) {
    return [new Paragraph({ text: "No progress entries available" })];
  }
  
  const content: Paragraph[] = [
    new Paragraph({
      text: `Total Progress Entries: ${entries.length}`,
      spacing: { before: 50, after: 50 }
    })
  ];
  
  // Group entries by project
  const entriesByProject: { [key: string]: any[] } = {};
  entries.forEach(entry => {
    const projectId = entry.projectId || entry.project_id;
    if (!entriesByProject[projectId]) {
      entriesByProject[projectId] = [];
    }
    entriesByProject[projectId].push(entry);
  });
  
  // Add entries by project
  Object.entries(entriesByProject).forEach(([projectId, projectEntries]) => {
    content.push(
      new Paragraph({
        text: `Project ID: ${projectId}`,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 50, after: 20 }
      }),
      new Paragraph({
        text: `Number of entries: ${projectEntries.length}`,
        spacing: { before: 10, after: 20 }
      })
    );
    
    // Add individual entries
    projectEntries.forEach((entry, index) => {
      content.push(
        new Paragraph({
          text: `Entry ${index + 1} - ${new Date(entry.date).toLocaleDateString()}`,
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 30, after: 10 }
        }),
        new Paragraph({
          text: `Distance completed: ${entry.distanceCompleted || entry.distance_completed || 0} meters`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Time spent: ${entry.timeSpent || entry.time_spent || 0} hours`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Workers present: ${entry.workersPresent || entry.workers_present || 0}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Notes: ${entry.notes || 'No notes'}`,
          spacing: { before: 10, after: 20 }
        })
      );
    });
  });
  
  return content;
}

// Helper function to generate payment requests content
function generatePaymentContent(payments: any[]): Paragraph[] {
  if (!payments || payments.length === 0) {
    return [new Paragraph({ text: "No payment requests available" })];
  }
  
  const content: Paragraph[] = [
    new Paragraph({
      text: `Total Payment Requests: ${payments.length}`,
      spacing: { before: 50, after: 50 }
    })
  ];
  
  // Group payments by status
  const paymentsByStatus: { [key: string]: any[] } = {};
  payments.forEach(payment => {
    const status = payment.status || 'unknown';
    if (!paymentsByStatus[status]) {
      paymentsByStatus[status] = [];
    }
    paymentsByStatus[status].push(payment);
  });
  
  // Add payments by status
  Object.entries(paymentsByStatus).forEach(([status, statusPayments]) => {
    content.push(
      new Paragraph({
        text: `${status.toUpperCase()} Payments (${statusPayments.length})`,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 50, after: 20 }
      })
    );
    
    // Add individual payments
    statusPayments.forEach((payment, index) => {
      content.push(
        new Paragraph({
          text: `Payment ${index + 1} - â‚¹${payment.amount.toFixed(2)}`,
          heading: HeadingLevel.HEADING_3,
          spacing: { before: 30, after: 10 }
        }),
        new Paragraph({
          text: `Description: ${payment.description || 'No description'}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Requested by: ${payment.requestedBy || payment.requested_by || 'Unknown'}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Requested on: ${new Date(payment.requestedAt || payment.requested_at).toLocaleDateString()}`,
          spacing: { before: 10, after: 10 }
        }),
        new Paragraph({
          text: `Project ID: ${payment.projectId || payment.project_id || 'Unknown'}`,
          spacing: { before: 10, after: 20 }
        })
      );
    });
  });
  
  return content;
}

// Export a helper function to be used by storage-management page
export async function generateDocx(data: ReportData): Promise<Blob> {
  return generateWordReport(data);
}
